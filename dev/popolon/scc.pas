(*<scc.pas>
 * Library for SCC soundchip handling.
 * Thanks to BIFI's website at http://bifi.msxnet.org/msxnet//tech/scc
 * CopyLeft (c) since 1995 by PopolonY2k.
 *)

(**
  *
  * $Id: scc.pas 103 2020-06-17 00:40:53Z popolony2k $
  * $Author: popolony2k $
  * $Date: 2020-06-17 00:40:53 +0000 (Wed, 17 Jun 2020) $
  * $Revision: 103 $
  * $HeadURL: file:///svn/p/oldskooltech/code/msx/trunk/msxdos/pascal/scc.pas $
  *)

(*
 * This module depends on folowing include files (respect the order):
 * - types.pas;
 * - sndchips.pas;
 *)

Const
       { SCC related constants }
       ctSCCRegCounter                     = $7F;   { SCC register counter   }
       ctSCCPortCounter                    = $03;   { SCC port counter       }

       { SCC registers base addresses definitions }
       ctSCCWaveformBaseAddress  : Integer = $9800; { Waveform base address  }
       ctSCCFrequencyBaseAddress : Integer = $9880; { Frequency base address }
       ctSCCAmplitudeBaseAddress : Integer = $988A; { Amplitude base address }
       ctSCCMixerBaseAddress     : Integer = $988F; { Mixer base address     }


(**
  * SCC base address array definition.
  *)
Type PSCCBaseAddresses = ^TSCCBaseAddresses;
     TSCCBaseAddresses = Array[0..3] Of Integer;

(**
  * Local module variables.
  *)
Var
      __nSCCPrimarySlot,
      __nSCCSecondarySlot : Byte;
      __aSCCBaseAddresses : TSCCBaseAddresses;
      __pSCCBaseAddresses : PSCCBaseAddresses;


(**
  * Write data to SCC sound chip using internal variable parameter;
  * @param __nSCCPrimarySlot The SCC primary slot;
  * @param __nSCCSecondarySlot The SCC secondary slot;
  * @param __pSndChipArrayParms The address of an array containing the SCC
  * data like below:
  * item[0] := SCC Port;
  * item[1] := SCC Register;
  * item[2] := SCC Data;
  *)
Procedure WriteSCCDirect{( __nSCCPrimarySlot,
                           __nSCCSecondarySlot : Byte;
                           __pSndChipArrayParms : Pointer ) };
Begin
  (*
   * The ASM routine below is located in the .\ASM\ project folder
   * and was generated by INLASS.
   *)
  Inline(
          $ED/$5B/__pSndChipArrayParms{        LD DE,(__pSndChipArrayParms)}
          /$1A                        {        LD A,(DE)                   }
          /$6F                        { BASADR LD L,A                      }
          /$26/$00                    {        LD H,00H                    }
          /$29                        {        ADD HL,HL                   }
          /$ED/$4B/__pSCCBaseAddresses{        LD BC,(__pSCCBaseAddresses) }
          /$09                        {        ADD HL,BC                   }
          /$7E                        {        LD A,(HL)                   }
          /$23                        {        INC HL                      }
          /$66                        {        LD H,(HL)                   }
          /$6F                        {        LD L,A                      }
          /$13                        { SELREG INC DE                      }
          /$1A                        {        LD A,(DE)                   }
          /$4F                        {        LD C,A                      }
          /$06/$00                    {        LD B,0                      }
          /$09                        {        ADD HL,BC                   }
          /$13                        {        INC DE                      }
          /$1A                        {        LD A,(DE)                   }
          /$47                        {        LD B,A                      }
          /$EB                        {        EX DE,HL                    }
          /$2A/$FF/$FF                { SAVSLT LD HL,(SEC_SLOT)            }
          /$0E/$A8                    {        LD C,PPI_SSEL               }
          /$F3                        {        DI                          }
          /$ED/$60                    {        IN H,(C)                    }
          /$3A/__nSCCSecondarySlot    {        LD A,(__nSCCSecondarySlot)  }
          /$4F                        {        LD C,A                      }
          /$3A/__nSCCPrimarySlot      {        LD A,(__nSCCPrimarySlot)    }
          /$D3/$A8                    {        OUT (PPI_SSEL),A            }
          /$79                        {        LD A,C                      }
          /$32/$FF/$FF                {        LD (SEC_SLOT),A             }
          /$78                        { WRTREG LD A,B                      }
          /$12                        {        LD (DE),A                   }
          /$7D                        { RESSLT LD A,L                      }
          /$2F                        {        CPL                         }
          /$32/$FF/$FF                {        LD (SEC_SLOT),A             }
          /$7C                        {        LD A,H                      }
          /$FB                        {        EI                          }
          /$D3/$A8                    {        OUT (PPI_SSEL),A            }
                                      {        END                         } );
End;

(**
  * Write data to SCC sound chip.
  * @param nPrimarySlot The SCC primary slot;
  * @param nSecondarySlot The SCC secondary slot;
  * @param nPort The port that register are categorized;
  * @param nRegister The register index to write data;
  * @param nData The data to be written;
  *)
Procedure WriteSCC( nPrimarySlot, nSecondarySlot : Byte;
                    nPort, nRegister, nData : Byte );
Var
       aSCCArrayParms : Array [0..2] Of Byte;

Begin
  aSCCArrayParms[0] := nPort;
  aSCCArrayParms[1] := nRegister;
  aSCCArrayParms[2] := nData;

  __nSCCPrimarySlot    := nPrimarySlot;
  __nSCCSecondarySlot  := nSecondarySlot;
  __pSndChipArrayParms := Ptr( Addr( aSCCArrayParms[0] ) );

  WriteSCCDirect{( __nSCCPrimarySlot,
                   __nSCCSecondarySlot,
                   __pSndChipArrayParms )};
End;

(**
  * Reset the SCC soundchip.
  * @param nPrimarySlot The SCC primary slot;
  * @param nSecondarySlot The SCC secondary slot;
  *)
Procedure ResetSCC( nPrimarySlot, nSecondarySlot : Byte );
Var
       nPort,
       nRegister      : Byte;
       aSCCArrayParms : Array [0..2] Of Byte;

Begin
  __nSCCPrimarySlot    := nPrimarySlot;
  __nSCCSecondarySlot  := nSecondarySlot;
  __pSndChipArrayParms := Ptr( Addr( aSCCArrayParms[0] ) );
  aSCCArrayParms[2]    := 0;               { SCC Data }

  Inline( $F3 );    { DI }

  For nPort := 0 To ctSCCPortCounter Do    { Port }
  Begin
    aSCCArrayParms[0] := nPort;

    For nRegister := 0 To ctSCCRegCounter Do   { Register }
    Begin
      aSCCArrayParms[1] := nRegister;

      WriteSCCDirect{( __nSCCPrimarySlot,
                       __nSCCSecondarySlot,
                       __pSndChipArrayParms )};
    End;
  End;

  Inline( $FB );    { EI }
End;

(**
  * Set the base address table for using with SCC Assembly calls.
  *)
Procedure InitSCCBaseAddresses;
Begin
  __aSCCBaseAddresses[0] := ctSCCWaveformBaseAddress;
  __aSCCBaseAddresses[1] := ctSCCFrequencyBaseAddress;
  __aSCCBaseAddresses[2] := ctSCCAmplitudeBaseAddress;
  __aSCCBaseAddresses[3] := ctSCCMixerBaseAddress;
  __pSCCBaseAddresses    := Ptr( Addr( __aSCCBaseAddresses ) );
End;
