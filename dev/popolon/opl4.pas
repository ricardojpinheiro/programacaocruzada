(*<opl4.pas>
 * Library for OPL4 (YMF278B) soundchip handling.
 * CopyLeft (c) since 1995 by PopolonY2k.
 *)

(**
  *
  * $Id: opl4.pas 103 2020-06-17 00:40:53Z popolony2k $
  * $Author: popolony2k $
  * $Date: 2020-06-17 00:40:53 +0000 (Wed, 17 Jun 2020) $
  * $Revision: 103 $
  * $HeadURL: file:///svn/p/oldskooltech/code/msx/trunk/msxdos/pascal/opl4.pas $
  *)

(*
 * This module depends on folowing include files (respect the order):
 * - types.pas;
 * - sndchips.pas;
 *)

Const
       { OPL4 related constants }
       ctPortYMF278BFMReg1        : Byte = $C4;   { YMF278B FM register 1 }
       ctPortYMF278BFMData1       : Byte = $C5;   { YMF278B FM data 1 }
       ctPortYMF278BFMReg2        : Byte = $C6;   { YMF278B FM register 2 }
       ctPortYMF278BFMData2       : Byte = $C7;   { YMF278B FM data 2 }
       ctPortYMF278BWaveReg       : Byte = $7E;   { YMF278B Wave register }
       ctPortYMF278BWaveData      : Byte = $7F;   { YMF278B Wave data }
       (*ctPortYMF278BStatus        : Byte = $C4;   { YMF278B Status }*)
       ctOPL4FMDataPortCounter    : Byte = $15;   { OPL4 data port counter }

(**
  * Write data to OPL4 FM sound chip using internal variable parameter;
  * @param __pSndChipArrayParms The address of an array containing the OPL4
  * data like below:
  * item[0] := OPL4 Port;
  * item[1] := OPL4 Register;
  * item[2] := OPL4 Data;
  *)
Procedure WriteOPL4FMDirect{( __pSndChipArrayParms : Pointer )};
Begin
  (*
   * The ASM routine below is located in the .\ASM\ project folder
   * and was generated by INLASS.
   *)
  Inline(
          $2A/__pSndChipArrayParms {        LD HL,(__pSndChipArrayParms) }
          /$7E                     {        LD A,(HL)                    }
          /$FE/$02                 {        CP OPL4_WAV                  }
          /$28/$19                 {        JR Z,WRTWAVE                 }
                                   { MACRO  WRT_OPL4 1,OPL4FMR2          }
          /$23                     {        INC HL                       }
          /$7E                     {        LD A,(HL)                    }
          /$0E/$C6                 {        LD C,OPL4FMR2                }
          /$ED/$79                 {        OUT (C),A                    }
          /$DB/$C4                 { WAITA1 IN A,(OPL4STS)               }
          /$E6/$01                 {        AND OPL4_BSY                 }
          /$20/$FA                 {        JR NZ,WAITA1                 }
                                   { MACRO  WRT_OPL4 2,OPL4FMD2          }
          /$23                     {        INC HL                       }
          /$7E                     {        LD A,(HL)                    }
          /$0E/$C7                 {        LD C,OPL4FMD2                }
          /$ED/$79                 {        OUT (C),A                    }
          /$DB/$C4                 { WAITB2 IN A,(OPL4STS)               }
          /$E6/$01                 {        AND OPL4_BSY                 }
          /$20/$FA                 {        JR NZ,WAITB2                 }
          /$C9                     {        RET                          }
                                   { MACRO  WRTWAVE WRT_OPL4 3,OPL4WAVR  }
          /$23                     {        INC HL                       }
          /$7E                     {        LD A,(HL)                    }
          /$0E/$7E                 {        LD C,OPL4WAVR                }
          /$ED/$79                 {        OUT (C),A                    }
          /$DB/$C4                 { WAITC3 IN A,(OPL4STS)               }
          /$E6/$01                 {        AND OPL4_BSY                 }
          /$20/$FA                 {        JR NZ,WAITC3                 }
                                   { MACRO  WRT_OPL4 4,OPL4WAVD          }
          /$23                     {        INC HL                       }
          /$7E                     {        LD A,(HL)                    }
          /$0E/$7F                 {        LD C,OPL4WAVD                }
          /$ED/$79                 {        OUT (C),A                    }
          /$DB/$C4                 { WAITD4 IN A,(OPL4STS)               }
          /$E6/$01                 {        AND OPL4_BSY                 }
          /$20/$FA                 {        JR NZ,WAITD4                 }
                                   {        END                          } );
End;

(**
  * Write data to OPL4 FM sound chip port. This is a wrapper to the
  * @see WriteOPL4FMDirect;
  * @param nPort The port that register are categorized;
  * @param nRegister The register index to write data;
  * @param nData The data to be written;
  *)
Procedure WriteOPL4FM( nPort, nRegister, nData : Byte );
Var
       aOPL4ArrayParms : Array [0..2] Of Byte;

Begin
  aOPL4ArrayParms[0] := nPort;
  aOPL4ArrayParms[1] := nRegister;
  aOPL4ArrayParms[2] := nData;

  __pSndChipArrayParms := Ptr( Addr( aOPL4ArrayParms ) );

  WriteOPL4FMDirect{( __pSndChipArrayParms )};
End;

(**
  * Reset all FM registers based on their register addresses.
  * Check the YMF278B (OPL4) datasheet.
  *)
Procedure ResetFM( nBaseAddress : Byte );
Var
       aOPL4ArrayParms : Array [0..2] Of Byte;
       nRegister       : Byte;

Begin
  aOPL4ArrayParms[2]   := $FF;
  __pSndChipArrayParms := Ptr( Addr( aOPL4ArrayParms ) );

  For nRegister := 0 To ctOPL4FMDataPortCounter Do
  Begin
    aOPL4ArrayParms[0] := 1;   { Port }
    aOPL4ArrayParms[1] := ( nBaseAddress + nRegister );
    WriteOPL4FMDirect{( __pSndChipArrayParms )};
    aOPL4ArrayParms[0] := 2;   { Port }
    WriteOPL4FMDirect{( __pSndChipArrayParms )};

    Delay( ctSndChipResetDelay );
  End;
End;

(**
  * Reset the OPL4 soundchip.
  *)
Procedure ResetOPL4;
Begin
  (* Reset all FM registers *)
  ResetFM( $20 );
  ResetFM( $40 );
  ResetFM( $60 );
  ResetFM( $80 );
  ResetFM( $E0 );
End;
